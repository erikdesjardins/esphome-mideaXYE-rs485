# Send commands every 150ms if we have any queued up.
# Per RE info, real controllers poll devices every 130ms, ~30ms for sending and 100ms for receiving.
# We use 150ms to give a bit of extra buffer.
- interval: 150ms
  then:
    - if:
        condition:
          lambda: 'return id(send_queue_len) > 0;'
        then:
          - uart.write: !lambda |-
              std::vector<uint8_t> message = {id(send_queue)[0].begin(), id(send_queue)[0].end()};

              // shift the queue down
              for (size_t i = 1; i < id(send_queue_len); i++) {
                id(send_queue)[i - 1] = id(send_queue)[i];
              }
              id(send_queue_len)--;

              return message;

# Send control updates (if any), follow me (every 30s), and update the status every second.
- interval: 1s
  then:
    lambda: !lambda |-
      struct payload {
        uint8_t _0x01;
        uint8_t _0x06;
        uint8_t _0x07;
        uint8_t _0x08;
        uint8_t _0x09;
        uint8_t _0x0A;
        uint8_t _0x0B;
        uint8_t _0x0C;
      };
      auto enqueue_send = [](payload x) {
        if (id(send_queue_len) >= id(send_queue).size()) {
          ESP_LOGW("custom", "Send queue full, dropping command %02X", x._0x01);
          return;
        }

        // For RE info, see:
        // https://codeberg.org/xye/xye
        // https://github.com/HomeOps/ESPHome-Midea-XYE/blob/92957c08c002185e7125be8da501617b3db5167c/esphome/components/midea_xye/PROTOCOL.md
        auto& message = id(send_queue)[id(send_queue_len)];
        message[0x00] = 0xAA;     // Preamble (0xAA)
        message[0x01] = x._0x01;  // Commmand
        message[0x02] = 0x00;     // Destination ID (0x00-0x3F device id, 0xFF broadcast)
        message[0x03] = 0x00;     // Source ID (0x00-0x3F device id)
        message[0x04] = 0x00;     // From Master (0x80) [Note: my unit does not respond unless this is 0x00]
        message[0x05] = 0x00;     // Source ID (0x00-0x3F device id)
        message[0x06] = x._0x06;  // Payload
        message[0x07] = x._0x07;  // Payload
        message[0x08] = x._0x08;  // Payload
        message[0x09] = x._0x09;  // Payload
        message[0x0A] = x._0x0A;  // Payload
        message[0x0B] = x._0x0B;  // Payload
        message[0x0C] = x._0x0C;  // Payload
        message[0x0D] = ~x._0x01; // Command check
        message[0x0E] = 0x00;     // CRC (to be calculated)
        message[0x0F] = 0x55;     // Prologue (0x55)

        uint32_t crc = 0;
        for (uint8_t x : message) {
          crc += x;
        }
        message[0x0E] = static_cast<uint8_t>(~crc);

        id(send_queue_len)++;
      };

      // NOTE: message ordering here is important.
      // For example, if mode is switched on at the same time as follow me is enabled,
      // we need to send the control update first, since follow me is invalidated on mode change.

      ////////////////////////////////////////
      // C3 - Set (control updates)
      ////////////////////////////////////////

      if (id(new_input)) {
        id(new_input) = false;

        uint8_t op_bytes;
        if (id(op_mode).state == "off") {
          op_bytes = 0x00;
        } else if (id(op_mode).state == "auto") {
          op_bytes = 0x90;
        } else if (id(op_mode).state == "cool") {
          op_bytes = 0x88;
        } else if (id(op_mode).state == "dry") {
          op_bytes = 0x82;
        } else if (id(op_mode).state == "heat") {
          op_bytes = 0x84;
        } else if (id(op_mode).state == "fan_only") {
          op_bytes = 0x81;
        } else {
          op_bytes = 0x00;
          ESP_LOGW("custom", "Defaulting to off, invalid op mode input: %s", id(op_mode).state.c_str());
        }

        uint8_t fan_bytes;
        if (id(fan_mode).state == "high") {
          fan_bytes = 0x01;
        } else if (id(fan_mode).state == "auto") {
          fan_bytes = 0x80;
        } else if (id(fan_mode).state == "medium") {
          fan_bytes = 0x02;
        } else if (id(fan_mode).state == "low") {
          fan_bytes = 0x04;
        } else {
          fan_bytes = 0x80;
          ESP_LOGW("custom", "Defaulting to auto, invalid fan input: %s", id(fan_mode).state.c_str());
        }

        uint8_t encoded_temp;
        if (id(use_fahrenheit)) {
          encoded_temp = static_cast<uint8_t>(std::round(id(set_temp).state)) + 0x87;
        } else {
          // Bizarrely, the set temp is in integer C, even though everything else is in 0.5C increments.
          // When set to 0.5C via the remote, the reported temperature is floored in C0 responses, so do the same here.
          encoded_temp = static_cast<uint8_t>(std::floor(id(set_temp).state));
        }

        enqueue_send({
          ._0x01 = 0xC3,
          ._0x06 = op_bytes,
          ._0x07 = fan_bytes,
          ._0x08 = encoded_temp,
          ._0x09 = id(mode_flag_bytes),
        });
      }

      ////////////////////////////////////////
      // C6 - Extended Set (follow me)
      ////////////////////////////////////////

      if (id(uptime_sensor).state - id(last_follow_me_message) > 30) {
        id(last_follow_me_message) = static_cast<uint32_t>(id(uptime_sensor).state);

        do {
          // If the unit is off, do not send follow me packets
          if (id(op_mode).state == "off") {
            break;
          }

          // If we hit the timeout without an update, turn off follow me
          if (id(follow_me).state && id(uptime_sensor).state - id(last_follow_me_update) > ${follow_me_timeout}) {
            ESP_LOGW("custom", "Follow Me timeout reached, disabling Follow Me");
            id(follow_me).turn_off();
          }

          uint8_t follow_me_cmd;
          if (id(follow_me).state) {
            if (!id(unit_follow_me_init)) {
              // 1. Follow me enabled but not initialized: send initialization packet
              id(unit_follow_me_init) = true;
              follow_me_cmd = id(use_fahrenheit) ? 0x46 : 0x6;
            } else {
              // 2. Follow me already initialized: send update packet
              follow_me_cmd = id(use_fahrenheit) ? 0x42 : 0x2;
            }
          } else {
            if (id(unit_follow_me_init)) {
              // 3. Follow me disabled but was initialized: send stop packet
              id(unit_follow_me_init) = false;
              follow_me_cmd = id(use_fahrenheit) ? 0x44 : 0x4;
            } else {
              // 4. Follow me disabled and not initialized: do nothing
              break;
            }
          }

          uint8_t follow_me_encoded_temp = static_cast<uint8_t>(std::floor(id(follow_me_temp).state)); // always in C

          // Send C6 query for follow me
          enqueue_send({
            ._0x01 = 0xC6,
            ._0x0A = follow_me_cmd,
            ._0x0B = follow_me_encoded_temp,
          });
        } while (0);
      }

      ////////////////////////////////////////
      // C0 - Query
      ////////////////////////////////////////

      enqueue_send({
        ._0x01 = 0xC0
      });

      ////////////////////////////////////////
      // C4 - Extended Query
      ////////////////////////////////////////

      enqueue_send({
        ._0x01 = 0xC4
      });
# Send commands every 150ms if we have any queued up.
# Per RE info, real controllers poll devices every 130ms, ~30ms for sending and 100ms for receiving.
# We use 150ms to give a bit of extra buffer.
- interval: 150ms
  then:
    - if:
        condition:
          lambda: 'return id(send_queue_len) > 0;'
        then:
          - uart.write: !lambda |-
              std::vector<uint8_t> message = {id(send_queue)[0].begin(), id(send_queue)[0].end()};

              // shift the queue down
              for (size_t i = 1; i < id(send_queue_len); i++) {
                id(send_queue)[i - 1] = id(send_queue)[i];
              }
              id(send_queue_len)--;

              return message;

# Send control updates (if any), follow me (every 30s), and update the status every second.
- interval: 1s
  then:
    lambda: !lambda |-
      struct payload {
        uint8_t _0x01;
        uint8_t _0x06;
        uint8_t _0x07;
        uint8_t _0x08;
        uint8_t _0x09;
        uint8_t _0x0A;
        uint8_t _0x0B;
        uint8_t _0x0C;
      };
      auto enqueue_send = [](payload x) {
        if (id(send_queue_len) >= id(send_queue).size()) {
          ESP_LOGW("custom", "Send queue full, dropping command %02X", x._0x01);
          return;
        }

        // For RE info, see:
        // https://codeberg.org/xye/xye
        // https://github.com/HomeOps/ESPHome-Midea-XYE/blob/92957c08c002185e7125be8da501617b3db5167c/esphome/components/midea_xye/PROTOCOL.md
        auto& message = id(send_queue)[id(send_queue_len)];
        message[0x00] = 0xAA;     // Preamble (0xAA)
        message[0x01] = x._0x01;  // Commmand
        message[0x02] = 0x00;     // Destination ID (0x00-0x3F device id, 0xFF broadcast)
        message[0x03] = 0x00;     // Source ID (0x00-0x3F device id)
        message[0x04] = 0x00;     // From Master (0x80) [Note: my unit does not respond unless this is 0x00]
        message[0x05] = 0x00;     // Source ID (0x00-0x3F device id)
        message[0x06] = x._0x06;  // Payload
        message[0x07] = x._0x07;  // Payload
        message[0x08] = x._0x08;  // Payload
        message[0x09] = x._0x09;  // Payload
        message[0x0A] = x._0x0A;  // Payload
        message[0x0B] = x._0x0B;  // Payload
        message[0x0C] = x._0x0C;  // Payload
        message[0x0D] = ~x._0x01; // Command check
        message[0x0E] = 0x00;     // CRC (to be calculated)
        message[0x0F] = 0x55;     // Prologue (0x55)

        uint32_t crc = 0;
        for (uint8_t x : message) {
          crc += x;
        }
        message[0x0E] = static_cast<uint8_t>(~crc);

        id(send_queue_len)++;
      };

      // NOTE: message ordering here is important.
      // For example, if mode is switched on at the same time as follow me is enabled,
      // we need to send the control update first, since follow me is invalidated on mode change.

      ////////////////////////////////////////
      // C3 - Set (control updates)
      ////////////////////////////////////////

      if (id(new_input)) {
        id(new_input) = false;

        uint8_t op_byte;
        if (id(op_mode).current_option() == "off") {
          op_byte = 0x00;
        } else if (id(op_mode).current_option() == "auto") {
          op_byte = 0x90;
        } else if (id(op_mode).current_option() == "cool") {
          op_byte = 0x88;
        } else if (id(op_mode).current_option() == "dry") {
          op_byte = 0x82;
        } else if (id(op_mode).current_option() == "heat") {
          op_byte = 0x84;
        } else if (id(op_mode).current_option() == "fan_only") {
          op_byte = 0x81;
        } else {
          op_byte = 0x00;
          ESP_LOGW("custom", "Defaulting to off, invalid op mode input: %s", id(op_mode).current_option().c_str());
        }

        uint8_t fan_byte;
        if (id(fan_mode).current_option() == "auto") {
          fan_byte = 0x80;
        } else if (id(fan_mode).current_option() == "high") {
          fan_byte = 0x01;
        } else if (id(fan_mode).current_option() == "medium") {
          fan_byte = 0x02;
        } else if (id(fan_mode).current_option() == "low") {
          fan_byte = 0x04;
        } else {
          fan_byte = 0x80;
          ESP_LOGW("custom", "Defaulting to auto, invalid fan input: %s", id(fan_mode).current_option().c_str());
        }

        // Possible setpoint values:
        //
        // Celsius range:    16 - 30 °C
        // Fahrenheit range: 60 - 86 °F
        //
        // Celsius:     0x00 - 0x0E [size: 15] (encoding: temp - 0x10)
        // Set °C:      0x0F        [size:  1] (sets display mode to °C)
        // Celsius:     0x10 - 0x1E [size: 15] (encoding: identity)
        // Set °C:      0x1F        [size:  1]
        // Celsius 0.5: 0x20 - 0x2E [size: 15] (encoding: temp - 0.5 + 0x10, for 0.5°C increments; last is 30.0°C)
        // Set °C:      0x2F        [size:  1]
        //              0x30 - 0x3F [size: 16] (setting values here causes weird behavior, like enabling fan_only mode)
        // Celsius:     0x40 - 0x4E [size: 15] (encoding: temp + 0x30)
        // Set °C:      0x4F        [size:  1]
        // Celsius:     0x50 - 0x5E [size: 15] (encoding: temp + 0x40; this is the "canonical" value it returns in C0/C4 responses)
        // Set °C:      0x5F        [size:  1]
        // Celsius 0.5: 0x60 - 0x6E [size: 15] (encoding: temp - 0.5 + 0x50, for 0.5°C increments; last is 30.0°C)
        // Set 0.5:     0x6F        [size:  1] (sets 0.5°C on the current setpoint)
        //              0x70 - 0x7F [size: 16] (setting values here causes weird behavior, like enabling fan_only mode)
        // Celsius->°F: 0x80 - 0x8E [size: 15] (encoding: temp in °C + 0x70 but displayed as °F; rounded to nearest-ish [first two tweaked to 60/62°F instead of 61/63°F])
        // Set °F:      0x8F        [size:  1] (sets display mode to °F; rounded to nearest-ish)
        // Celsius->°F: 0x90 - 0x9E [size: 15] (rounded to nearest-ish)
        // Set °F:      0x9F        [size:  1] (rounded to nearest-ish)
        // Celsius->°F: 0xA0 - 0xAE [size: 15] (rounded up...ish [I really don't know what they did here])
        // Set °F:      0xAF        [size:  1] (rounded up...ish)
        //              0xB0 - 0xBF [size: 16] (setting values here causes weird behavior, like enabling fan_only mode)
        //              0xC0 - 0xC2 [size:  3] (truncated Fahrenheit scale: 83, 84, 85°F)
        // Fahrehneit:  0xC3 - 0xDE [size: 28] (encoding: temp_f + 0x87; this is the "canonical" value it returns in C0/C4 responses; last is 86°F again)
        // Set °F:      0xDF        [size:  1] (rounded to nearest-ish)
        // Set °F:      0xE0        [size:  1] (rounded up...ish)
        // Fahrehneit:  0xE1 - 0xFE [size: 30] (encoding: messed up, with repeated values)
        //              0xFF        [size:  1] (ignored)
        uint8_t encoded_temp;
        if (id(use_fahrenheit)) {
          encoded_temp = static_cast<uint8_t>(std::round(id(set_temp).state)) + 0x87;
        } else {
          // Round to the nearest 0.5°C
          double temp_c = std::round(2.0 * id(set_temp).state) / 2.0;
          uint8_t whole_part = static_cast<uint8_t>(std::floor(temp_c));
          bool has_half = whole_part != temp_c;
          encoded_temp = whole_part + (has_half ? 0x50 : 0x40);
        }

        uint8_t mode_byte;
        if (id(preset_mode).current_option() == "sleep") {
          mode_byte = 0x01;
        } else if (id(preset_mode).current_option() == "boost") {
          mode_byte = 0x02;
        } else {
          mode_byte = 0x00;
        }
        if (id(vertical_swing).state) {
          mode_byte |= 0x04;
        }

        enqueue_send({
          ._0x01 = 0xC3,
          ._0x06 = op_byte,
          ._0x07 = fan_byte,
          ._0x08 = encoded_temp,
          ._0x0B = mode_byte,
        });
      }

      ////////////////////////////////////////
      // C6 - Extended Set (follow me)
      ////////////////////////////////////////

      if (id(uptime_sensor).state - id(last_follow_me_message) > 30) {
        id(last_follow_me_message) = static_cast<uint32_t>(id(uptime_sensor).state);

        do {
          // If the unit is off, do not send follow me packets
          if (id(op_mode).current_option() == "off") {
            break;
          }

          // If we hit the timeout without an update, turn off follow me
          if (id(follow_me).state && id(uptime_sensor).state - id(last_follow_me_update) > ${follow_me_timeout}) {
            ESP_LOGW("custom", "Follow Me timeout (${follow_me_timeout}s) reached, disabling");
            id(follow_me).turn_off();
          }

          uint8_t follow_me_cmd;
          if (id(follow_me).state) {
            if (!id(unit_follow_me_init)) {
              // 1. Follow me enabled but not initialized: send initialization packet
              id(unit_follow_me_init) = true;
              follow_me_cmd = id(use_fahrenheit) ? 0x46 : 0x6;
            } else {
              // 2. Follow me already initialized: send update packet
              follow_me_cmd = id(use_fahrenheit) ? 0x42 : 0x2;
            }
          } else {
            if (id(unit_follow_me_init)) {
              // 3. Follow me disabled but was initialized: send stop packet
              id(unit_follow_me_init) = false;
              follow_me_cmd = id(use_fahrenheit) ? 0x44 : 0x4;
            } else {
              // 4. Follow me disabled and not initialized: do nothing
              break;
            }
          }

          uint8_t follow_me_encoded_temp = static_cast<uint8_t>(std::floor(id(follow_me_temp).state)); // always in °C

          // Send C6 query for follow me
          enqueue_send({
            ._0x01 = 0xC6,
            ._0x0A = follow_me_cmd,
            ._0x0B = follow_me_encoded_temp,
          });
        } while (0);
      }

      ////////////////////////////////////////
      // C0 - Query
      ////////////////////////////////////////

      enqueue_send({
        ._0x01 = 0xC0
      });

      ////////////////////////////////////////
      // C4 - Extended Query
      ////////////////////////////////////////

      enqueue_send({
        ._0x01 = 0xC4
      });

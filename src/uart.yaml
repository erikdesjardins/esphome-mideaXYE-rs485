tx_pin: ${tx_pin}
rx_pin: ${rx_pin}
baud_rate: ${baud_rate}
stop_bits: 1
parity: NONE
data_bits: 8
debug:
  direction: BOTH
  dummy_receiver: true
  after:
    bytes: 32
    timeout: 100ms
  sequence:
    - lambda: |-
        if (direction == UART_DIRECTION_TX) {
          if (bytes.size() != 16) {
            ESP_LOGW("uart_debug", "Bad UART TX packet: bad size: %d", bytes.size());
            return;
          }

          if (bytes[0x01] == 0xC0 || bytes[0x01] == 0xC4) {
            UARTDebug::log_hex(direction, bytes, ' ');
          } else {
            ESP_LOGI(
              "uart_debug",
              ">>> "
              "%02X %02X %02X %02X %02X %02X %02X %02X "
              "%02X %02X %02X %02X %02X %02X %02X %02X",
              bytes[0x00], bytes[0x01], bytes[0x02], bytes[0x03], bytes[0x04], bytes[0x05], bytes[0x06], bytes[0x07],
              bytes[0x08], bytes[0x09], bytes[0x0A], bytes[0x0B], bytes[0x0C], bytes[0x0D], bytes[0x0E], bytes[0x0F]
            );
          }

          // Ignore packets we're sending
          return;
        }

        if (bytes.size() != 32) {
          ESP_LOGW("uart_debug", "Bad UART packet: bad size: %d", bytes.size());
          return;
        }

        if (bytes[0x01] == 0xC0 || bytes[0x01] == 0xC4) {
          UARTDebug::log_hex(direction, bytes, ' ');
        } else {
          ESP_LOGI(
            "uart_debug",
            "<<< "
            "%02X %02X %02X %02X %02X %02X %02X %02X "
            "%02X %02X %02X %02X %02X %02X %02X %02X "
            "%02X %02X %02X %02X %02X %02X %02X %02X "
            "%02X %02X %02X %02X %02X %02X %02X %02X",
            bytes[0x00], bytes[0x01], bytes[0x02], bytes[0x03], bytes[0x04], bytes[0x05], bytes[0x06], bytes[0x07],
            bytes[0x08], bytes[0x09], bytes[0x0A], bytes[0x0B], bytes[0x0C], bytes[0x0D], bytes[0x0E], bytes[0x0F],
            bytes[0x10], bytes[0x11], bytes[0x12], bytes[0x13], bytes[0x14], bytes[0x15], bytes[0x16], bytes[0x17],
            bytes[0x18], bytes[0x19], bytes[0x1A], bytes[0x1B], bytes[0x1C], bytes[0x1D], bytes[0x1E], bytes[0x1F]
          );
        }

        // Verification

        {
          if (bytes[0x00] != 0xAA) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x00): bad preamble: %02X", bytes[0x00]);
            return;
          }

          // bytes[0x01] is the command flag, to be handled below

          if (bytes[0x02] != 0x00) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x02): unexpected direction flag: %02X", bytes[0x02]);
            return;
          }
          if (bytes[0x03] != 0x00) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x03): unexpected destination: %02X", bytes[0x03]);
            return;
          }
          if (bytes[0x04] != 0x00) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x04): unexpected source: %02X", bytes[0x04]);
            return;
          }
          if (bytes[0x05] != bytes[0x03]) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x05): destination check vs. destination: %02X vs. %02X", bytes[0x05], bytes[0x03]);
            return;
          }

          // bytes[0x06] to bytes[0x1D] is the payload

          uint32_t crc = 0;
          for (size_t i = 0; i < bytes.size(); i++) {
            if (i == 0x1E) {
              continue; // skip CRC byte
            }
            crc += bytes[i];
          }
          crc = ~crc;
          if (bytes[0x1E] != static_cast<uint8_t>(crc)) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x1E): CRC vs. expected: %02X vs. %02X", bytes[0x1E], static_cast<uint8_t>(crc));
            return;
          }

          if (bytes[0x1F] != 0x55) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x1F): bad prologue: %02X", bytes[0x1F]);
            return;
          }
        }

        // Message handling

        switch (bytes[0x01]) {
          ////////////////////////////////////////
          // C0 - Query
          ////////////////////////////////////////
          case 0xC0: {
            // Don't overwrite pending control state which hasn't been sent yet.
            if (!id(new_input)) {
              // Operating mode
              const char* op_mode_str;
              const char* op_mode_detailed_str;
              switch (bytes[0x08]) {
                case 0x00:
                  op_mode_str = op_mode_detailed_str = "off";
                  break;
                case 0x10:
                  op_mode_str = "auto";
                  op_mode_detailed_str = "auto (15m startup)";
                  break;
                case 0x91:
                  op_mode_str = "auto";
                  op_mode_detailed_str = "auto (heating)";
                  break;
                case 0x98:
                  op_mode_str = "auto";
                  op_mode_detailed_str = "auto (cooling)";
                  break;
                case 0x94:
                  op_mode_str = "auto";
                  op_mode_detailed_str = "auto (idle)";
                  break;
                case 0x88:
                  op_mode_str = op_mode_detailed_str = "cool";
                  break;
                case 0x82:
                  op_mode_str = op_mode_detailed_str = "dry";
                  break;
                case 0x84:
                  op_mode_str = op_mode_detailed_str = "heat";
                  break;
                case 0x81:
                  op_mode_str = op_mode_detailed_str = "fan_only";
                  break;
                default:
                  op_mode_str = op_mode_detailed_str = "off";
                  ESP_LOGW("custom", "Unknown op mode byte: %02X", bytes[0x08]);
              }
              id(op_mode).publish_state(op_mode_str);
              id(op_mode_detailed).publish_state(op_mode_detailed_str);

              // Fan mode
              const char* fan_mode_str;
              const char* fan_mode_detailed_str;
              switch (bytes[0x09]) {
                case 0x80:
                  fan_mode_str = fan_mode_detailed_str = "auto";
                  break;
                case 0x81:
                  fan_mode_str = "auto";
                  fan_mode_detailed_str = "auto (high)";
                  break;
                case 0x82:
                  fan_mode_str = "auto";
                  fan_mode_detailed_str = "auto (medium)";
                  break;
                case 0x84:
                  fan_mode_str = "auto";
                  fan_mode_detailed_str = "auto (low)";
                  break;
                case 0x01:
                  fan_mode_str = fan_mode_detailed_str = "high";
                  break;
                case 0x02:
                  fan_mode_str = fan_mode_detailed_str = "medium";
                  break;
                case 0x04:
                  fan_mode_str = fan_mode_detailed_str = "low";
                  break;
                default:
                  fan_mode_str = fan_mode_detailed_str = "auto";
                  ESP_LOGW("custom", "Unknown fan mode byte: %02X", bytes[0x09]);
              }
              id(fan_mode).publish_state(fan_mode_str);
              id(fan_mode_detailed).publish_state(fan_mode_detailed_str);

              if (!id(use_fahrenheit)) {
                // For some reason, this does not use the 0.5C encoding, even though you can set the unit to 0.5C increments using the remote.
                // Sometimes, the 0x40 bit is set though, which has unclear meaning.
                id(set_temp).publish_state(bytes[0x0A] & ~0x40);
              }

              const char* preset_mode_str;
              if (bytes[0x14] & 0x01) {
                preset_mode_str = "sleep";
              } else if (bytes[0x14] & 0x02) {
                preset_mode_str = "boost";
              } else {
                preset_mode_str = "none";
              }
              bool vertical_swing_enabled = bytes[0x14] & 0x04;
              id(preset_mode).publish_state(preset_mode_str);
              id(vertical_swing).publish_state(vertical_swing_enabled);
            }

            // these sensors are offset by 0x28 and in units of 0.5C regardless of what mode the unit is in
            id(t1_temp).publish_state((bytes[0x0B] - 0x28) / 2.0);
            id(t2a_temp).publish_state((bytes[0x0C] - 0x28) / 2.0);
            id(t2b_temp).publish_state((bytes[0x0D] - 0x28) / 2.0);
            id(t3_temp).publish_state((bytes[0x0E] - 0x28) / 2.0);

            id(current).publish_state(bytes[0x0F]);

            id(compressor_status).publish_state(bytes[0x13] & 0x01);

            id(error_flags).publish_state(bytes[0x16] | (bytes[0x17] << 8));

            id(protect_flags).publish_state(bytes[0x18] | (bytes[0x19] << 8));
            id(defrost_status).publish_state(bytes[0x18] == 0x02);

            break;
          }
          ////////////////////////////////////////
          // C3 - Set (control updates)
          ////////////////////////////////////////
          case 0xC3: {
            // Ignore
            break;
          }
          ////////////////////////////////////////
          // C4 - Extended Query
          ////////////////////////////////////////
          case 0xC4: {
            id(t4_temp).publish_state((bytes[0x15] - 0x28) / 2.0);

            if (id(use_fahrenheit))
            {
              // sometimes this temporarily gives erroneous values before correcting itself, ignore them
              if (bytes[18] > 0x87 && bytes[18] < 215) {
                id(set_temp).publish_state(bytes[18] - 0x87);
              }
            }

            break;
          }
          ////////////////////////////////////////
          // C6 - Extended Set (follow me)
          ////////////////////////////////////////
          case 0xC6: {
            // Ignore
            break;
          }

          default: {
            ESP_LOGW("uart_debug", "Unknown command: %02X", bytes[0x01]);
            return;
          }
        }

tx_pin: ${tx_pin}
rx_pin: ${rx_pin}
baud_rate: ${baud_rate}
stop_bits: 1
parity: NONE
data_bits: 8
debug:
  direction: BOTH
  dummy_receiver: true
  after:
    bytes: 32
    timeout: 100ms
  sequence:
    - lambda: |-
        static uint8_t last_c0_op_mode = 0x00;
        static uint8_t last_c0_fan_mode = 0x00;
        static uint8_t last_c0_set_temp = 0x00;
        static bool last_c0_vertical_swing = false;

        if (direction == UART_DIRECTION_TX) {
          if (bytes.size() != 16) {
            ESP_LOGW("uart_debug", "Bad UART TX packet: bad size: %d", bytes.size());
            return;
          }

          if (bytes[0x01] == 0xC0 || bytes[0x01] == 0xC4 || bytes[0x01] == 0xC6) {
            UARTDebug::log_hex(direction, bytes, ' ');
          } else {
            ESP_LOGI(
              "uart_debug",
              ">>> "
              "%02X %02X %02X %02X %02X %02X %02X %02X "
              "%02X %02X %02X %02X %02X %02X %02X %02X",
              bytes[0x00], bytes[0x01], bytes[0x02], bytes[0x03], bytes[0x04], bytes[0x05], bytes[0x06], bytes[0x07],
              bytes[0x08], bytes[0x09], bytes[0x0A], bytes[0x0B], bytes[0x0C], bytes[0x0D], bytes[0x0E], bytes[0x0F]
            );
          }

          // Ignore packets we're sending
          return;
        }

        if (bytes.size() != 32) {
          ESP_LOGW("uart_debug", "Bad UART packet: bad size: %d", bytes.size());
          return;
        }

        if (bytes[0x01] == 0xC0 || bytes[0x01] == 0xC4 || bytes[0x01] == 0xC6) {
          UARTDebug::log_hex(direction, bytes, ' ');
        } else {
          ESP_LOGI(
            "uart_debug",
            "<<< "
            "%02X %02X %02X %02X %02X %02X %02X %02X "
            "%02X %02X %02X %02X %02X %02X %02X %02X "
            "%02X %02X %02X %02X %02X %02X %02X %02X "
            "%02X %02X %02X %02X %02X %02X %02X %02X",
            bytes[0x00], bytes[0x01], bytes[0x02], bytes[0x03], bytes[0x04], bytes[0x05], bytes[0x06], bytes[0x07],
            bytes[0x08], bytes[0x09], bytes[0x0A], bytes[0x0B], bytes[0x0C], bytes[0x0D], bytes[0x0E], bytes[0x0F],
            bytes[0x10], bytes[0x11], bytes[0x12], bytes[0x13], bytes[0x14], bytes[0x15], bytes[0x16], bytes[0x17],
            bytes[0x18], bytes[0x19], bytes[0x1A], bytes[0x1B], bytes[0x1C], bytes[0x1D], bytes[0x1E], bytes[0x1F]
          );
        }

        // Verification

        {
          if (bytes[0x00] != 0xAA) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x00): bad preamble: %02X", bytes[0x00]);
            return;
          }

          // bytes[0x01] is the command flag, to be handled below

          if (bytes[0x02] != 0x00) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x02): unexpected direction flag: %02X", bytes[0x02]);
            return;
          }
          if (bytes[0x03] != 0x00) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x03): unexpected destination: %02X", bytes[0x03]);
            return;
          }
          if (bytes[0x04] != 0x00) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x04): unexpected source: %02X", bytes[0x04]);
            return;
          }
          if (bytes[0x05] != bytes[0x03]) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x05): destination check vs. destination: %02X vs. %02X", bytes[0x05], bytes[0x03]);
            return;
          }

          // bytes[0x06] to bytes[0x1D] is the payload

          uint32_t crc = 0;
          for (size_t i = 0; i < bytes.size(); i++) {
            if (i == 0x1E) {
              continue; // skip CRC byte
            }
            crc += bytes[i];
          }
          crc = ~crc;
          if (bytes[0x1E] != static_cast<uint8_t>(crc)) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x1E): CRC vs. expected: %02X vs. %02X", bytes[0x1E], static_cast<uint8_t>(crc));
            return;
          }

          if (bytes[0x1F] != 0x55) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x1F): bad prologue: %02X", bytes[0x1F]);
            return;
          }
        }

        // Message handling

        switch (bytes[0x01]) {
          ////////////////////////////////////////
          // C0 - Query
          ////////////////////////////////////////
          case 0xC0: {
            if (id(new_input)) {
              // Don't overwrite pending control state which hasn't been sent yet.
              break;
            }

            if (bytes[0x06] != 0x10) {
              ESP_LOGW("custom", "C0 byte 0x06 (capabilities 1?) changed: %02X", bytes[0x06]);
            }

            if (bytes[0x07] != 0x30) {
              ESP_LOGW("custom", "C0 byte 0x07 (capabilities 2?) changed: %02X", bytes[0x07]);
            }

            // Operating mode
            const char* op_mode_str;
            const char* op_mode_status_str;
            switch (bytes[0x08]) {
              case 0x00:
                op_mode_str = op_mode_status_str = "off";
                break;
              case 0x10:
                op_mode_str = "auto";
                op_mode_status_str = "auto (15m startup)";
                break;
              case 0x91:
                op_mode_str = "auto";
                op_mode_status_str = "auto (heating)";
                break;
              case 0x98:
                op_mode_str = "auto";
                op_mode_status_str = "auto (cooling)";
                break;
              case 0x94:
                op_mode_str = "auto";
                op_mode_status_str = "auto (idle)";
                break;
              case 0x88:
                op_mode_str = op_mode_status_str = "cool";
                break;
              case 0x82:
                op_mode_str = op_mode_status_str = "dry";
                break;
              case 0x84:
                op_mode_str = op_mode_status_str = "heat";
                break;
              case 0x81:
                op_mode_str = op_mode_status_str = "fan_only";
                break;
              default:
                op_mode_str = op_mode_status_str = "off";
                ESP_LOGW("custom", "C0 byte 0x08 (op mode) unknown value: %02X", bytes[0x08]);
            }
            id(op_mode).publish_state(op_mode_str);
            id(op_mode_status).publish_state(op_mode_status_str);
            last_c0_op_mode = bytes[0x08];

            // Fan mode
            const char* fan_mode_str;
            const char* fan_mode_status_str;
            switch (bytes[0x09]) {
              case 0x80:
                fan_mode_str = fan_mode_status_str = "auto";
                break;
              case 0x81:
                fan_mode_str = "auto";
                fan_mode_status_str = "auto (high)";
                break;
              case 0x82:
                fan_mode_str = "auto";
                fan_mode_status_str = "auto (medium)";
                break;
              case 0x84:
                fan_mode_str = "auto";
                fan_mode_status_str = "auto (low)";
                break;
              case 0x01:
                fan_mode_str = fan_mode_status_str = "high";
                break;
              case 0x02:
                fan_mode_str = fan_mode_status_str = "medium";
                break;
              case 0x04:
                fan_mode_str = fan_mode_status_str = "low";
                break;
              default:
                fan_mode_str = fan_mode_status_str = "auto";
                ESP_LOGW("custom", "C0 byte 0x09 (fan mode) unknown value: %02X", bytes[0x09]);
            }
            id(fan_mode).publish_state(fan_mode_str);
            id(fan_mode_status).publish_state(fan_mode_status_str);
            last_c0_fan_mode = bytes[0x09];

            double new_set_temp;
            if (bytes[0x0A] >= 0x50 && bytes[0x0A] <= 0x5E) {
              // °C
              new_set_temp = bytes[0x0A] - 0x40;
            } else if (bytes[0x0A] >= 0x60 && bytes[0x0A] <= 0x6D) {
              // °C + 0.5
              new_set_temp = bytes[0x0A] - 0x50 + 0.5;
            } else if (bytes[0x0A] >= 0xC3 && bytes[0x0A] <= 0xDD) {
              // °F
              new_set_temp = bytes[0x0A] - 0x87;
            } else {
              new_set_temp = 0;
            }
            // For some reason, setpoints are always rounded to the nearest 1°C, even though you can set 0.5°C increments.
            // So we ignore a discrepancy of less than 1 degree with the current state, and just assume it's set to the right value.
            // However, we also need to handle the 0.5°C encoding that we send, since it will be echoed back to us temporarily.
            // Note that this could be used to detect when the unit is still processing input (e.g. by using a non-canonical temperature encoding)
            // in order to ignore potential temporary states, but I haven't done that because it shouldn't happen normally (except for this specific case).
            double delta = std::abs(id(set_temp).state - new_set_temp);
            if (new_set_temp == 0.0) {
              ESP_LOGW("custom", "C0 byte 0x0A (set temp) has unknown encoding: %02X", bytes[0x0A]);
            } else if (delta < 1.0) {
              ESP_LOGD("custom", "C0 byte 0x0A (set temp) is close to current temp, ignoring: %0.1f (current: %0.1f)", new_set_temp, id(set_temp).state);
            } else {
              id(set_temp).publish_state(new_set_temp);
            }
            last_c0_set_temp = bytes[0x0A];

            // these sensors are offset by 0x28 and in units of 0.5°C regardless of what mode the unit is in
            id(t1_temp).publish_state((bytes[0x0B] - 0x28) / 2.0);
            id(t2a_temp).publish_state((bytes[0x0C] - 0x28) / 2.0);
            id(t2b_temp).publish_state((bytes[0x0D] - 0x28) / 2.0);
            id(t3_temp).publish_state((bytes[0x0E] - 0x28) / 2.0);

            id(current).publish_state(bytes[0x0F]);

            if (bytes[0x10] != 0xFF) {
              ESP_LOGW("custom", "C0 byte 0x10 (frequency) changed: %02X", bytes[0x10]);
            }

            // bytes[0x11] is timer start, ignoring since it doesn't make sense to use it
            // bytes[0x12] is timer stop, ignoring since it doesn't make sense to use it

            id(compressor_status).publish_state(bytes[0x13] & 0x01);
            if (bytes[0x13] & ~0x01) {
              ESP_LOGW("custom", "C0 byte 0x13 (status?) unknown bits set: %02X (unknown: %02X)", bytes[0x13], bytes[0x13] & ~0x01);
            }

            const char* preset_mode_str;
            if (bytes[0x14] & 0x01) {
              preset_mode_str = "sleep";
            } else if (bytes[0x14] & 0x02) {
              preset_mode_str = "boost";
            } else {
              preset_mode_str = "none";
            }
            bool vertical_swing_enabled = bytes[0x14] & 0x04;
            id(preset_mode).publish_state(preset_mode_str);
            last_c0_vertical_swing = vertical_swing_enabled;
            if (bytes[0x14] & ~(0x01 | 0x02 | 0x04)) {
              ESP_LOGW("custom", "C0 byte 0x14 (preset/swing) unknown bits set: %02X (unknown: %02X)", bytes[0x14], bytes[0x14] & ~(0x01 | 0x02 | 0x04));
            }

            if (bytes[0x15] != 0x00) {
              ESP_LOGW("custom", "C0 byte 0x15 (oper flags?) changed: %02X", bytes[0x15]);
            }

            id(error_flags).publish_state(bytes[0x16] | (bytes[0x17] << 8));

            id(protect_flags).publish_state(bytes[0x18] | (bytes[0x19] << 8));
            id(defrost_status).publish_state(bytes[0x18] == 0x02);

            if (bytes[0x1A] != 0x00) {
              ESP_LOGW("custom", "C0 byte 0x1A (CCM comm error flags) changed: %02X", bytes[0x1A]);
            }

            if (bytes[0x1B] != 0xFF) {
              ESP_LOGW("custom", "C0 byte 0x1B (unknown) changed: %02X", bytes[0x1B]);
            }

            if (bytes[0x1C] || bytes[0x1D]) {
              ESP_LOGW("custom", "C0 bytes 0x1C-0x1D (reserved) changed: %02X %02X", bytes[0x1C], bytes[0x1D]);
            }

            break;
          }
          ////////////////////////////////////////
          // C3 - Set (control updates)
          ////////////////////////////////////////
          case 0xC3: {
            // Ignore
            break;
          }
          ////////////////////////////////////////
          // C4 - Extended Query
          ////////////////////////////////////////
          case 0xC4: {
            if (id(new_input)) {
              // Don't overwrite pending control state which hasn't been sent yet.
              break;
            }

            id(fetched_initial_state) = true;

            if (bytes[0x06] != 0x05) {
              ESP_LOGW("custom", "C4 byte 0x06 (unknown) changed: %02X", bytes[0x06]);
            }

            if (bytes[0x07] != 0x00) {
              ESP_LOGW("custom", "C4 byte 0x07 (unknown) changed: %02X", bytes[0x07]);
            }

            if (bytes[0x08] != 0x02) {
              ESP_LOGW("custom", "C4 byte 0x08 (unknown) changed: %02X", bytes[0x08]);
            }

            if (bytes[0x09] != 0x30) {
              ESP_LOGW("custom", "C4 byte 0x09 (same as C0 0x07 capabilities?) changed: %02X", bytes[0x09]);
            }

            if (bytes[0x0A] != 0x0E) {
              ESP_LOGW("custom", "C4 byte 0x0A (unknown) changed: %02X", bytes[0x0A]);
            }

            bool vertical_swing_enabled = bytes[0x0B] & 0x10;
            bool horizontal_swing_enabled = bytes[0x0B] & 0x20;
            id(vertical_swing).publish_state(vertical_swing_enabled);
            id(horizontal_swing).publish_state(horizontal_swing_enabled);
            if (vertical_swing_enabled != last_c0_vertical_swing) {
              ESP_LOGW("custom", "C4 byte 0x0B (swing?) vertical swing state changed: %02X (vs. last C0: %02X)", bytes[0x0B] & 0x10, last_c0_vertical_swing ? 0x10 : 0x00);
            }
            if (bytes[0x0B] & ~(0x10 | 0x20)) {
              ESP_LOGW("custom", "C4 byte 0x0B (swing?) unknown bits set: %02X (unknown: %02X)", bytes[0x0B], bytes[0x0B] & ~(0x10 | 0x20));
            }

            if (bytes[0x0C] || bytes[0x0D]) {
              ESP_LOGW("custom", "C4 bytes 0x0C-0x0D (reserved?) changed: %02X %02X", bytes[0x0C], bytes[0x0D]);
            }

            if (bytes[0x0E] != 0x00) {
              ESP_LOGW("custom", "C4 byte 0x0E (unknown) changed: %02X", bytes[0x0E]);
            }

            if (bytes[0x0F] != 0x00) {
              ESP_LOGW("custom", "C4 byte 0x0F (aux heat flags?) changed: %02X", bytes[0x0F]);
            }

            if (bytes[0x10] != last_c0_op_mode) {
              ESP_LOGW("custom", "C4 byte 0x10 (op mode?) changed: %02X (vs. last C0: %02X)", bytes[0x10], last_c0_op_mode);
            }

            if (bytes[0x11] != last_c0_fan_mode) {
              ESP_LOGW("custom", "C4 byte 0x11 (fan mode?) changed: %02X (vs. last C0: %02X)", bytes[0x11], last_c0_fan_mode);
            }

            if (bytes[0x12] != last_c0_set_temp) {
              ESP_LOGW("custom", "C4 byte 0x12 (set temp) changed: %02X (vs. last C0: %02X)", bytes[0x12], last_c0_set_temp);
            }

            if (bytes[0x13] != 0xBC) {
              ESP_LOGW("custom", "C4 byte 0x13 (unknown) changed: %02X", bytes[0x13]);
            }

            if (bytes[0x14] != 0xD6) {
              ESP_LOGW("custom", "C4 byte 0x14 (unknown) changed: %02X", bytes[0x14]);
            }

            id(t4_temp).publish_state((bytes[0x15] - 0x28) / 2.0);
            id(t5_temp).publish_state((bytes[0x16] - 0x28) / 2.0);

            if (bytes[0x17] || bytes[0x18] || bytes[0x19] || bytes[0x1A] || bytes[0x1B] || bytes[0x1C] || bytes[0x1D]) {
              ESP_LOGW(
                "custom",
                "C4 bytes 0x17-0x1D (reserved?) changed: "
                "%02X %02X %02X %02X %02X %02X %02X",
                bytes[0x17], bytes[0x18], bytes[0x19], bytes[0x1A], bytes[0x1B], bytes[0x1C], bytes[0x1D]
              );
            }

            break;
          }
          ////////////////////////////////////////
          // C6 - Extended Set (follow me)
          ////////////////////////////////////////
          case 0xC6: {
            // Ignore
            break;
          }

          default: {
            ESP_LOGW("custom", "Unknown command: %02X", bytes[0x01]);
            return;
          }
        }

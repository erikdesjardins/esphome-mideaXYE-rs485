tx_pin: ${tx_pin}
rx_pin: ${rx_pin}
baud_rate: ${baud_rate}
stop_bits: 1
parity: NONE
data_bits: 8
debug:
  direction: BOTH
  dummy_receiver: true
  after:
    bytes: 32
    timeout: 100ms
  sequence:
    - lambda: |-
        UARTDebug::log_hex(direction, bytes, ' ');

        if (direction == UART_DIRECTION_TX) {
          // Ignore packets we're sending
          return;
        }

        // Verification

        {
          if (bytes.size() != 32) {
            ESP_LOGW("uart_debug", "Bad UART packet: bad size: %d", bytes.size());
            return;
          }

          if (bytes[0x00] != 0xAA) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x00): bad preamble: %02X", bytes[0x00]);
            return;
          }

          // bytes[0x01] is the command flag, to be handled below

          if (bytes[0x02] != 0x00) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x02): unexpected direction flag: %02X", bytes[0x02]);
            return;
          }
          if (bytes[0x03] != 0x00) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x03): unexpected destination: %02X", bytes[0x03]);
            return;
          }
          if (bytes[0x04] != 0x00) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x04): unexpected source: %02X", bytes[0x04]);
            return;
          }
          if (bytes[0x05] != bytes[0x03]) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x05): destination check vs. destination: %02X vs. %02X", bytes[0x05], bytes[0x03]);
            return;
          }

          // bytes[0x06] to bytes[0x1D] is the payload

          uint32_t crc = 0;
          for (size_t i = 0; i < bytes.size(); i++) {
            if (i == 0x1E) {
              continue; // skip CRC byte
            }
            crc += bytes[i];
          }
          crc = ~crc;
          if (bytes[0x1E] != static_cast<uint8_t>(crc)) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x1E): CRC vs. expected: %02X vs. %02X", bytes[0x1E], static_cast<uint8_t>(crc));
            return;
          }

          if (bytes[0x1F] != 0x55) {
            ESP_LOGW("uart_debug", "Bad UART packet (byte 0x1F): bad prologue: %02X", bytes[0x1F]);
            return;
          }
        }

        // Message handling

        switch (bytes[0x01]) {
          ////////////////////////////////////////
          // C0 - Query
          ////////////////////////////////////////
          case 0xC0: {
            // Don't overwrite pending control state which hasn't been sent yet.
            if (!id(new_input)) {
              // Operating mode
              const char* op_mode_str;
              const char* op_mode_detailed_str;
              switch (bytes[8]) {
                case 0x00:
                  op_mode_str = op_mode_detailed_str = "off";
                  break;
                case 0x10:
                  op_mode_str = "auto";
                  op_mode_detailed_str = "auto (15m startup)";
                  break;
                case 0x91:
                  op_mode_str = "auto";
                  op_mode_detailed_str = "auto (heating)";
                  break;
                case 0x98:
                  op_mode_str = "auto";
                  op_mode_detailed_str = "auto (cooling)";
                  break;
                case 0x94:
                  op_mode_str = "auto";
                  op_mode_detailed_str = "auto (idle)";
                  break;
                case 0x88:
                  op_mode_str = op_mode_detailed_str = "cool";
                  break;
                case 0x82:
                  op_mode_str = op_mode_detailed_str = "dry";
                  break;
                case 0x84:
                  op_mode_str = op_mode_detailed_str = "heat";
                  break;
                case 0x81:
                  op_mode_str = op_mode_detailed_str = "fan_only";
                  break;
                default:
                  op_mode_str = op_mode_detailed_str = "off";
                  ESP_LOGW("custom", "Unknown op mode byte: %02X", bytes[8]);
              }
              id(op_mode).publish_state(op_mode_str);
              id(op_mode_detailed).publish_state(op_mode_detailed_str);

              // Fan mode
              const char* fan_mode_str;
              const char* fan_mode_detailed_str;
              switch (bytes[9]) {
                case 0x80:
                  fan_mode_str = fan_mode_detailed_str = "auto";
                  break;
                case 0x81:
                  fan_mode_str = "auto";
                  fan_mode_detailed_str = "auto (high)";
                  break;
                case 0x82:
                  fan_mode_str = "auto";
                  fan_mode_detailed_str = "auto (medium)";
                  break;
                case 0x84:
                  fan_mode_str = "auto";
                  fan_mode_detailed_str = "auto (low)";
                  break;
                case 0x01:
                  fan_mode_str = fan_mode_detailed_str = "high";
                  break;
                case 0x02:
                  fan_mode_str = fan_mode_detailed_str = "medium";
                  break;
                case 0x04:
                  fan_mode_str = fan_mode_detailed_str = "low";
                  break;
                default:
                  fan_mode_str = fan_mode_detailed_str = "auto";
                  ESP_LOGW("custom", "Unknown fan mode byte: %02X", bytes[9]);
              }
              id(fan_mode).publish_state(fan_mode_str);
              id(fan_mode_detailed).publish_state(fan_mode_detailed_str);

              id(mode_flag_bytes) = bytes[17];

              // we only capture the celcius set point here, since it always comes back celcius no matter what mode the unit is in
              if (!id(use_fahrenheit)) {
                // For some reason, this does not use the 0.5C encoding, even though you can set the unit to 0.5C increments using the remote.
                // Sometimes, the 0x40 bit is set though, which has unclear meaning.
                id(set_temp).publish_state(bytes[10] & ~0x40);
              }
            }

            // these sensors are offset by 0x28 and in units of 0.5C regardless of what mode the unit is in
            id(t1_temp).publish_state((bytes[11] - 0x28) / 2.0);
            id(t2a_temp).publish_state((bytes[12] - 0x28) / 2.0);
            id(t2b_temp).publish_state((bytes[13] - 0x28) / 2.0);
            id(t3_temp).publish_state((bytes[14] - 0x28) / 2.0);

            // compressor status and defrost binary sensors. Defrost code may be different on other units, await user feedback
            // byte 19 can apparently indicate outdoor fan and compressor on some units, hence the bitwise comparison for compressor only
            id(compressor_status).publish_state(bytes[19] & 0x01);
            id(defrost_status).publish_state(bytes[24] == 0x02);

            // error codes. TODO: could use some more investigation
            id(error_codes).publish_state({"E1: " + std::to_string(bytes[23]) + " E2: " + std::to_string(bytes[24])});

            break;
          }
          ////////////////////////////////////////
          // C3 - Set (control updates)
          ////////////////////////////////////////
          case 0xC3: {
            // Ignore
            break;
          }
          ////////////////////////////////////////
          // C4 - Extended Query
          ////////////////////////////////////////
          case 0xC4: {
            id(t4_temp).publish_state((bytes[0x15] - 0x28) / 2.0);

            if (id(use_fahrenheit))
            {
              // sometimes this temporarily gives erroneous values before correcting itself, ignore them
              if (bytes[18] > 0x87 && bytes[18] < 215) {
                id(set_temp).publish_state(bytes[18] - 0x87);
              }
            }

            break;
          }
          ////////////////////////////////////////
          // C6 - Extended Set (follow me)
          ////////////////////////////////////////
          case 0xC6: {
            // Ignore
            break;
          }

          default: {
            ESP_LOGW("uart_debug", "Unknown command: %02X", bytes[0x01]);
            return;
          }
        }
